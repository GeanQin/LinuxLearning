#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<unistd.h>

/*
 * 每个进程都有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址。
 * 虚拟地址可通过每个进程上的页表(在每个进程的内核虚拟地址空间)与物理地址进行映射，获得真正物理地址。
 * 如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。
 * 
 * 虚拟地址空间由低地址到高地址分别为：
 * 1、只读段：该部分空间只能读，不可写(包括：代码段、rodata 段(C常量字符串和#define定义的常量))。
 * 2、数据段：保存全局变量、静态变量的空间。
 * 3、堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。
 * 4、文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。
 * 5、栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。
 * 6、内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)。
 * 
 * 注：只声明不定义也会分配空间。
 */

static int a=0;//静态变量存放数据段
int b=1;//全局变量存放数据段

int main(){
	int c=2;//局部变量存放在栈
	char s1[]="012";//局部变量存放在栈
	char *s2="012";//字符常量存放只读段
	char *s3=(char*)malloc(4);//malloc存放堆
/*
 * 默认情况下，malloc函数分配内存，
 * 如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），
 * 那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。
 * _edata指针（glibc里面定义）指向数据段的最高地址。
 */
	char *s4=(char*)malloc(140000);
	strcpy(s3,"012");
	strcpy(s4,"012");
	printf("a=%d,b=%d,c=%d,s1=%s,s2=%s,s3=%s,s4=%s\n",a,b,c,s1,s2,s3,s4);
//	printf("a=%d,b=%d,c=%d,s1=%s,s2=%s,s3=%s\n",a,b,c,s1,s2,s3);
	while(1){
		sleep(1000);
	}
	return 0;
}
